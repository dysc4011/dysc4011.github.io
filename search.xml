<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vim的常用快捷操作(在vscode里使用vim) 长期更新</title>
      <link href="2021/02/15/vim/"/>
      <url>2021/02/15/vim/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近趁着寒假有时间，随便鼓捣了会Ubuntu和vim，在练习了一段时间vim后，发现它的使用思想大大提高了我的编辑效率。但vim需要在linux系统中使用，因此我就在vscode里安装了vim插件进行使用，下面是我总结的一些vim常用的快捷键 方便记忆</p><h2 id="vim基本快捷键"><a href="#vim基本快捷键" class="headerlink" title="vim基本快捷键"></a>vim基本快捷键</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>上下左右 kjhl</p><p>数字 + gg 跳到某一行</p><p>command模式下输入行号 同样是跳到某一行</p><p>f{char} 光标跳到下一个char所在的位置<br>F{char} 光标跳到上一个char所在的位置</p><p>t{char} 光标跳到下一个char所在的位置之前<br>T{char} 光标跳到上一个char所在的位置之前</p><p>, 往前查找上次的字符<br>; 重复上次的字符查找操作</p><h3 id="动作-motion"><a href="#动作-motion" class="headerlink" title="动作(motion)"></a>动作(motion)</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>i 插入</p><p>shift + i 在行首插入</p><p>a 在光标后插入</p><p>shift + a 在行尾插入</p><p>o 在下一行开始插入</p><p>shift + o 在上一行插入</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>/char 查找</p><p>n 往下查找</p><p>shift + n 往上查找</p><p>*同样</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>p 在下一行复制</p><p>shitf + p 在上一行复制</p><h4 id="行内指令"><a href="#行内指令" class="headerlink" title="行内指令"></a>行内指令</h4><p>w 跳到一个单词的开头</p><p>b 跳到本单词或一个单词的开头</p><p>e 跳到本单词或一个单词的结尾</p><p>ge 跳到上一个单词的结尾</p><p>0 跳到行首</p><p>^ 跳到从行首开始的第一个非空字符</p><p>$ 跳到行尾</p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>dd 删除一整行</p><p>x 删除光标所在的字符</p><p>s 删除光标所在的字符并且进入insert模式</p><p>dw 删除光标所在单词以后的字符</p><p>shift + d 删除当前行内光标所在的之后的所有内容</p><p>shift + c 删除当前行内光标所在的之后的所有内容并进入insert模式</p><p>shift + s 删除当前行并进入insert模式(保持原有缩进)</p><h4 id="行间移动"><a href="#行间移动" class="headerlink" title="行间移动"></a>行间移动</h4><p>shift + g 跳到最后一行</p><p>gg 跳到第一行</p><p>行号+g 跳到某一行</p><p>:行号 跳到某一行</p><p>数字+j 快速向下移动 数字 行 (w b e hjkl 都能如此使用)</p>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript箭头函数与普通函数</title>
      <link href="2021/02/12/JavaScript%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/"/>
      <url>2021/02/12/JavaScript%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><ul><li>普通函数：function(){}</li><li>箭头函数: ()=&gt;{}</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> words = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> words_normal = words.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item += <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数只有一个参数无需写括号</span></span><br><span class="line"><span class="comment">// 如果只有一个表达式的时候可以不添加大括号</span></span><br><span class="line"><span class="keyword">let</span> words_arrow = words.map(<span class="function"><span class="params">item</span> =&gt;</span> item += <span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(words_arrow);</span><br></pre></td></tr></table></figure><h3 id="new-与-原型"><a href="#new-与-原型" class="headerlink" title="new 与 原型"></a>new 与 原型</h3><p>箭头函数不能创建new函数的实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Star.prototype.name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> normal = <span class="keyword">new</span> Star();</span><br><span class="line"><span class="built_in">console</span>.log(normal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Arrow = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> arrow = <span class="keyword">new</span> Arrow();</span><br></pre></td></tr></table></figure><p><strong>得到如下结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210212171324243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhbnl1YW5h,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>箭头函数无arguments对象</p><p>但仍然可以让箭头函数看起来有arguments的效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="built_in">arguments</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrow = normal(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 由于作用域链的关系，箭头函数保存了arguments的长度</span></span><br><span class="line"><span class="built_in">console</span>.log(arrow()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>箭头函数的this值取决于外部普通函数里的this值</p><p>箭头函数不能通过call apply bind来改变this的值，<br>但箭头函数仍然可以调用call apply bind方法</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://img-blog.csdnimg.cn/20210212171228809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhbnl1YW5h,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 箭头函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的基本使用</title>
      <link href="2021/02/12/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>2021/02/12/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="ubuntu下-安装git"><a href="#ubuntu下-安装git" class="headerlink" title="ubuntu下 安装git"></a>ubuntu下 安装git</h2><ol><li>打开终端，输入sudo apt-get install git</li><li>安装完成后，查看版本号 git –version</li><li>配置git<ol><li>配置用户名 git config –global user.name “”</li><li>配置邮箱 git config –global user.email “”</li></ol></li></ol><h2 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h2><ol><li>提交步骤<ol><li>git init <strong>初始化git仓库</strong></li><li>git status <strong>查看文件状态</strong></li><li>git add 文件列表 <strong>追踪文件</strong></li><li>git commit -m 提交信息 <strong>向仓库中提交代码</strong></li><li>git log <strong>查看提交信息</strong></li></ol></li><li>撤销<ul><li>用暂存区中的文件覆盖工作目录中的文件： git checkout 文件</li><li>将文件从暂存区中删除： git rm –cached 文件</li><li>将git仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录： git rest –hard commitID</li></ul></li></ol><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>使用分支，可以使开发者从开发主线分离出来，以免影响主线</p><h3 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h3><p>主分支(master)就是第一次向git仓库提交更新记录时自动产生的一个分支</p><h3 id="开发分支"><a href="#开发分支" class="headerlink" title="开发分支"></a>开发分支</h3><p>开发分支(develop)作为开发的分支，基于master分支创建</p><h3 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h3><p>功能分支(feature)作为开发具体功能的分支，基于开发分支创建</p><h2 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h2><ul><li>git branch <strong>查看分支</strong></li><li>git branch 分支名称 <strong>创建分支</strong></li><li>git checkout 分支名称 <strong>切换分支</strong></li><li>git merge 来源分支 <strong>合并分支</strong> (来源分支依然存在)</li><li>git branch -d 分支名称 <strong>删除分支</strong> (分支被合并后才允许删除) (-D强制删除)</li></ul><h2 id="暂时保存更改"><a href="#暂时保存更改" class="headerlink" title="暂时保存更改"></a>暂时保存更改</h2><p>在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的副本，临时转向其他工作。</p><p>使用场景：分支临时切换</p><ul><li>存储临时变动：git stash</li><li>恢复改动：git stash pop</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记-第二章</title>
      <link href="2021/01/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>2021/01/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p> 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</p><p>物理层主要任务：确定与传输媒体<strong>接口</strong>有关的一些特性</p><ol><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格，接口形状、<strong>引线数目</strong>、<strong>引脚数量</strong>和排列情况</li><li>电气特性：规定传输二进制位时，线路上信号的<strong>电压范围</strong>、阻抗匹配、传输<strong>速率</strong>和<strong>距离</strong>限制等</li><li>功能特性：指明某条线上出现的<strong>某一电平表示何种意义</strong>，接口部件的信号线的用途</li><li>规程特性 (过程特性)：定义各条物理线路的工作<strong>规程和时序</strong>关系</li></ol><h2 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h2><h3 id="数据通信相关术语"><a href="#数据通信相关术语" class="headerlink" title="数据通信相关术语"></a>数据通信相关术语</h3><p>通信的目的是传送信息。</p><ul><li><strong>数据</strong>：传送信息的实体，通常是有意义的符号序列</li><li><strong>信号</strong>：数据的电气/电磁的表现，是数据在传输过程中的<strong>存在形式</strong><ul><li>数字信号：代表消息的参数取值是离散的</li><li>模拟信号：代表消息的参数取值是连续的</li></ul></li><li><strong>信源</strong>：产生和发送数据的源头</li><li><strong>信宿</strong>：接受数据的终点</li><li><strong>信道</strong>：信号的传输媒介。一般用来表示向某一个方向传送信息的介质。因此一条通信线路往往包含一条发送信道和一条接受信道</li><li>信道可通过<strong>传输信号</strong>分为 <em>模拟信道</em> 和 <em>数字信道</em>，还可通过<strong>传输介质</strong>分为 <em>无线信道</em> 和 <em>有线信道</em> </li></ul><h3 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h3><ol><li>单工通信：只有一个方向的通信而没有反方向的交互，仅需要<strong>一条</strong>信道</li><li>半双工通信：通信的双方都可以发送和接收信息，但任何一方都不能同时发送和接收，需要<strong>两条</strong>信道</li><li>全双工通信：通信双方可以同时发送和接收信息，也需要<strong>两条</strong>信道</li></ol><h3 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h3><ol><li>串行传输：速度<strong>慢</strong>，费用<strong>低</strong>，适合<strong>远</strong>距离</li><li>并行传输：速度<strong>快</strong>，费用<strong>高</strong>，适合<strong>近</strong>距离 (常用于计算机内部数据传输)</li></ol><h2 id="码元、波特、速率、带宽"><a href="#码元、波特、速率、带宽" class="headerlink" title="码元、波特、速率、带宽"></a>码元、波特、速率、带宽</h2><h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><p><strong>码元</strong>是指一个<strong>固定时长</strong>的<strong>信号波形</strong>(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长类的信号称为k进制码元，而该时长称为码元宽度，当码元的离散状态有M个时，此时码元为M进制码元</p><p><strong>1码元可以携带多个比特的信息量</strong></p><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量，可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>来表示</p><ol><li><p><strong>码元传输速率（1s传输多少个码元）</strong>：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可以称为脉冲个数或信号变化的次数)，单位是**波特(Baud)**。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。</p></li><li><p><strong>信息传输速率</strong>：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数(即比特数)，单位是比特/秒(b/s)</p><p> <strong>关系</strong>：若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M x n bit/s</p></li><li><p>带宽：表示在单位时间内从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”，常用来表示网络的通信线路所能传输数据的能力，单位是b/s</p></li></ol><h2 id="奈氏准则和香农定理"><a href="#奈氏准则和香农定理" class="headerlink" title="奈氏准则和香农定理"></a>奈氏准则和香农定理</h2><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><p><strong>影响失真的因素</strong>：</p><ol><li>码元传输速率</li><li>信号传输距离</li><li>噪声干扰</li><li>传输媒体质量</li></ol><h3 id="失真的一种现象-码间串扰"><a href="#失真的一种现象-码间串扰" class="headerlink" title="失真的一种现象-码间串扰"></a>失真的一种现象-码间串扰</h3><p>信道带宽：信道带宽是信道能通过的<strong>最高频率和最低频率之差</strong></p><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>奈氏准则：在理想低通(<strong>无噪声，带宽受限</strong>)条件下，为了避免码间串扰。极限码元传输速率为2W Baud，W是信道带宽，单位是Hz</p><p>理想低通信道下的极限数据传输率=2Wlog2(V) (b/s)<br>W是带宽 V是几种码元/码元的离散点平数目</p><ol><li>在任何信道中，<strong>码元传输的速率是有上限的</strong>。若传输速率超过此上限，就会出现严重的码间串扰问题。使接收端对码元的完全正确识别成为不可能</li><li>信道的<strong>频带越宽</strong>(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输</li><li><strong>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制</strong></li><li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调剂方法</li></ol><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p><strong>噪声</strong>存在于所有的电子设备和通道信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误，但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，<strong>信噪比</strong>就很重要</p><p>信噪比 = 信号的平均功率/噪声的平均功率，常记为S/N，并用分贝(dB)作为度量单位,即：</p><p>信噪比(dB) = 10log10(S/N)</p><p>香农定理：在带宽受限且噪声的信道中，为了不产生误差，信息的数据传输速率有上限值<br>信道的极限数据传输速率 = Wlog2(1+S/N) (b/s)<br>W是带宽，S/N是信噪比</p><ol><li>信道的<strong>带宽</strong>或信道中的<strong>信噪比</strong>越大，则信息的极限传输速率就越高</li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了</li><li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现<strong>无差错的传输</strong></li><li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少</li></ol><table><thead><tr><th>奈氏准则</th><th>香农定理</th></tr></thead><tbody><tr><td>带宽受限无噪声条件下，为了避免码间串扰，码元传输速率的上限2W Baud</td><td>带宽受限有噪音条件下的信息传输速率</td></tr><tr><td>理想低通信道下的极限数据传输率 = 2Wlog2(V)</td><td>信道的极限数据传输速率 = Wlog2(1+S/N)</td></tr><tr><td>要想提高数据率，就要提高带宽/采用更好的编码技术</td><td>要想提高数据率，就要提高带宽/信噪比</td></tr></tbody></table><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><h3 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h3><p><strong>信道</strong>：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接受信道<br><strong>信道上传送的信号可分为</strong></p><ol><li><strong>基带信号</strong>：将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输(基带传输)。来自<strong>信源</strong>的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的<strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号。</li><li><strong>宽带信号</strong>：将基带信号进行调制后形成的频分复用模拟信号，再传送到<strong>模拟信道</strong>上去传输(宽带传输)。把基带信号经过载波调制后，把信号的<strong>频率范围搬移到较高的频段</strong>以便再信道中传输(即仅在一段频率范围内能够通过信道)</li></ol><ul><li>在传输距离较近时，计算机网络采用<strong>基带传输方式</strong>(近距离衰减小，从而信号内容不易发生变化)</li><li>在传输距离较远时，计算机网络采用<strong>宽带传输方式</strong>(远距离衰减大，即使信号变化大也能最后过滤出来基带信号)</li></ul><h3 id="编码与调制-1"><a href="#编码与调制-1" class="headerlink" title="编码与调制"></a>编码与调制</h3><ul><li><p>数据转为<strong>数字信号</strong>采用<strong>编码</strong>的手段</p></li><li><p>数据转为<strong>模拟信号</strong>采用<strong>调制</strong>的手段</p></li><li><p>数字数据通过数字发送器转为数字信号采用编码的手段</p></li><li><p>数字数据通过调制器转为模拟信号采用调制的手段</p></li><li><p>模拟数据通过PCM编码器转为数字信号采用编码的手段</p></li><li><p>模拟数据通过放大器调制器转为模拟信号采用调制的手段</p></li></ul><h3 id="数字数据编码为数据信号"><a href="#数字数据编码为数据信号" class="headerlink" title="数字数据编码为数据信号"></a>数字数据编码为数据信号</h3><p><img src="https://img-blog.csdnimg.cn/20210125162912657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhbnl1YW5h,size_16,color_FFFFFF,t_70#pic_center"></p><ol><li><strong>非归零编码【NRZ】 （ 高 1 低 0 ）</strong>：编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方<strong>难以保持同步</strong></li><li>归零编码【RZ】：信号电平在一个码元之内都要恢复到零的这种编码方式</li><li>反向不归零编码【NRZI】：信号电平翻转表示为0，信号电平不变表示1</li><li><strong>曼彻斯特编码</strong>：将一个码元分成两个相等的间隔，前一个间隔为低电平后一个间隔为高电平表示码元：码元0则正好相反，也可以采用相反的规定，该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号(可用于同步)，又作数据信号，但它所占用的频带宽度是原始的基带宽度的两倍。每一个码元都被调成两个电平，所以<strong>数据传输速率只有调制速率的1/2</strong></li><li><strong>差分曼彻斯特编码 ( 同 1 异 0 )**：常用于局域网传输，其规则是：若码元位1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性</strong>强于**曼彻斯特编码</li><li>4B/5B编码：比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4给比特的数据，之后再传给接收方，因此称为4B/5V，编码效率为80%</li></ol><h3 id="数字数据调制为模拟信号"><a href="#数字数据调制为模拟信号" class="headerlink" title="数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h3><p>数字数据调制技术再发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程</p><p><img src="https://img-blog.csdnimg.cn/20210125163139786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhbnl1YW5h,size_16,color_FFFFFF,t_70#pic_center"></p><h3 id="模拟数据编码为数字信号"><a href="#模拟数据编码为数字信号" class="headerlink" title="模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h3><p>计算机内部处理的是二进制数据，处理的都是<strong>数字音频</strong>，所以需要将模拟音频通过采样、量化转换成有线个数字表示的离散序列(即实现<strong>音频数字化</strong>)</p><p>最典型的例子就是对音频信号进行编码的脉码调制(<strong>PCM</strong>)，在计算机应用中，能够达到<strong>最高保真水平</strong>的就是PCM编码，被广泛用于素材保存以及音乐欣赏、CD、DVD以及我们常见的WAV文件中均有应用，它主要包括三步：抽样、量化、编码</p><ol><li><strong>抽样</strong>：对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信号。为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样：*<em>采样频率&gt;2</em>信号最高频率**</li><li><strong>量化</strong>：把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量</li><li><strong>编码</strong>：把量化的结果转换为与之对应的二进制编码</li></ol><h3 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h3><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；模拟的声音数据是加载到模拟的载波信号中传输的</p><h2 id="物理层传输介质"><a href="#物理层传输介质" class="headerlink" title="物理层传输介质"></a>物理层传输介质</h2><h3 id="传输介质及分类"><a href="#传输介质及分类" class="headerlink" title="传输介质及分类"></a>传输介质及分类</h3><p>传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的<strong>物理通路</strong>。</p><p><strong>传输媒体并不是物理层</strong><br>传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。</p><p>传输介质分为<strong>导向性传输介质</strong>和<strong>非导向性传输介质</strong></p><ul><li>导向性传输介质：电磁波被导向沿着固体媒介(铜线/光纤)传播</li><li>非导向性传输介质：自由空间。介质可以是空气、真空、海水等</li></ul><h3 id="导向性传输介质–1-双绞线"><a href="#导向性传输介质–1-双绞线" class="headerlink" title="导向性传输介质–1.双绞线"></a>导向性传输介质–1.双绞线</h3><p><img src="https://img-blog.csdnimg.cn/20210125163230522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhbnl1YW5h,size_16,color_FFFFFF,t_70#pic_center"></p><p>双绞线是古老、又最常用的传输介质，它由<strong>两根</strong>采用一定规则并排<strong>绞合</strong>的、相互绝缘的<strong>铜导线</strong>组成</p><p><strong>绞合可以减少对相邻导线的电磁干扰</strong></p><p>为了进一步提高抗电磁干扰能力，可在双绞线的外面加上一个由<strong>金属丝</strong>编织成的屏蔽层，这就是<strong>屏蔽双绞线</strong>(STP)，无屏蔽层的双绞线就称为<strong>非屏蔽双绞线</strong>(UTP)</p><p>双绞线价格<strong>便宜</strong>，模拟传输和数字传输都可以使用双绞线。距离太远时，对于<strong>模拟传输</strong>，要用<strong>放大器</strong>放大衰减的信号；对于<strong>数字传输</strong>，要用<strong>中继器</strong>将失真的信号整形</p><h3 id="导向性传输介质–2-同轴电缆"><a href="#导向性传输介质–2-同轴电缆" class="headerlink" title="导向性传输介质–2.同轴电缆"></a>导向性传输介质–2.同轴电缆</h3><p><img src="https://img-blog.csdnimg.cn/20210125163314755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhbnl1YW5h,size_16,color_FFFFFF,t_70#pic_center"></p><p>同轴电缆由<strong>导体铜质芯线</strong>、<strong>绝缘层</strong>、<strong>网状编织屏蔽层</strong>和<strong>塑料外层</strong>构成。按特性阻抗数值的不同，通常将同轴电缆分为两类：50Ω同轴电缆和75Ω同轴电缆。其中，50Ω同轴电缆主要用于传送基带数字信号，又称为<strong>基带同轴电缆</strong>，它在局域网中得到广泛应用；75Ω同轴电缆主要用于传送宽带信号，又称为<strong>宽带同轴电缆</strong>，它主要用于有线电视系统</p><p><strong>同轴电缆与双绞线的比较</strong></p><p>由于外导体屏蔽层的作用，同轴电缆抗干扰特性比双绞线好，被广泛用于传输较高速率的数据，其<strong>传输距离</strong>更远，但<strong>价格</strong>较双绞线贵</p><h3 id="导向性传输介质–3-光纤"><a href="#导向性传输介质–3-光纤" class="headerlink" title="导向性传输介质–3.光纤"></a>导向性传输介质–3.光纤</h3><p><img src="https://img-blog.csdnimg.cn/20210125163346146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhbnl1YW5h,size_16,color_FFFFFF,t_70#pic_center"></p><p>光纤通信就是利用光导纤维(简称光纤)传递光脉冲来进行通信，有光脉冲表示1，无光脉冲表示0，而可见光的频率大约是10^8MHz，因此光纤通信系统的<strong>带宽远远大于</strong>目前其他各种传输媒体的带宽</p><p>光纤主要由<strong>纤芯(实心的)**和</strong>包层<strong>，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现</strong>全反射**，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去</p><p><strong>单模光纤与多模光纤</strong></p><p><img src="https://img-blog.csdnimg.cn/2021012516253046.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhbnl1YW5h,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><table><thead><tr><th></th><th>定义</th><th>光源</th><th>特点</th></tr></thead><tbody><tr><td>单模光纤</td><td>一种在横向模式直接传输光信号的光纤</td><td>定向性很好的激光二极管</td><td>衰耗小，适合远距离传输</td></tr><tr><td>多模光纤</td><td>有多种传输光信号模式的光纤</td><td>发光二极管</td><td>易失真，适合近距离传输</td></tr><tr><td><strong>光纤的特点</strong></td><td></td><td></td><td></td></tr></tbody></table><ol><li><strong>传输损耗小</strong>，中继距离长，对远距离传输特别经济</li><li><strong>抗雷电和电磁干扰性能好</strong></li><li>无串音干扰，保密性好，也<strong>不易被窃听或截取</strong></li><li><strong>体积小，重量轻</strong></li></ol><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><ul><li>无线电波(信号向<strong>所有方向</strong>传播)：较强<strong>穿透能力</strong>，可传远距离，广泛用于通信领域(如手机通信)</li><li>微波(信号<strong>固定方向</strong>传播)：微博通信频率较高、频段范围广，因此数据率很高。</li><li>红外线、激光(信号<strong>固定方向</strong>传播)：把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号。再在空间中传播</li></ul><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p><strong>中继器的功能</strong>：对信号进行<strong>再生和还原</strong>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络长度</p><p><strong>中继器的两端</strong>：</p><ol><li>两端的网络部分是网段，而不是子网，适用于完全相同的<strong>两类</strong>网络的互连，且两个网段速率要相同</li><li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误或不适用于网段的数据</li><li>两端可连相同媒体，也可连不同媒体</li><li>中继器两端的网段一定要是同一个协议。</li></ol><p><strong>5-4-3规则</strong>：</p><p>网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。</p><h3 id="集线器-多口中继器"><a href="#集线器-多口中继器" class="headerlink" title="集线器(多口中继器)"></a>集线器(多口中继器)</h3><p><strong>集线器的功能</strong>：对信号进行再生<strong>放大转发</strong>，对衰减的信号进行放大，接着转发到其他所有处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备</p><p><strong>集线器不能分割冲突域</strong></p><p><strong>连在集线器上的工作主机平分带宽</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记-第一章</title>
      <link href="2021/01/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>2021/01/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h3><ul><li>计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统</li><li>计算机网络是互连、自治的计算机集合</li></ul><h3 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h3><ol><li><strong>数据通信</strong>(连通性)</li><li><strong>资源共享</strong>(硬件、软件、数据)</li><li>分布式处理</li><li>提高可靠性</li><li>负载均衡</li></ol><h3 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h3><ol><li>组成部分：硬件、软件、协议</li><li>工作方式： <ol><li>边缘部分(用户直接使用 <strong>eg：主机、端系统</strong>) </li><li>核心部分(为边缘部分服务 <strong>eg：路由器</strong>)</li></ol></li><li>功能组成：<ol><li>通信子网(实现数据通信)</li><li>资源子网(实现资源共享/数据处理)</li></ol></li></ol><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><ol><li>按分布范围分：广域网WAN(交互技术)、城域网MAN、局域网WAN(广播技术)、个人局域网PAN</li><li>按使用者分：公用网(<strong>eg：中国电信</strong>)、专用网(<strong>eg：军队、政府</strong>) </li><li>按交换技术分：电路交换、报文交换、分组交换</li><li>按拓扑结构分：总线型、星型、环形、网状型(常用于广域网)</li><li>按传输技术分：广播式网络(共享公共通信信道)、点对点式网络(使用<strong>分组存储转发</strong>和<strong>路由选择机制</strong>)</li></ol><h3 id="标准化工作"><a href="#标准化工作" class="headerlink" title="标准化工作"></a>标准化工作</h3><ul><li>RFC-因特网标准的形式</li><li>RFC要上升为因特网正式标准的四个阶段：<ol><li>因特网草案(Internet Draft) 此阶段还不是RFC文档</li><li>建议标准(Proposed Standard) 从这个阶段开始成为RFC文档</li><li>因特网标准</li></ol></li></ul><h3 id="标准化的相关组织"><a href="#标准化的相关组织" class="headerlink" title="标准化的相关组织"></a>标准化的相关组织</h3><ul><li><strong>国际标准化组织ISO</strong> <em>(OSI参考模型、HDLC协议)</em></li><li>国际电信联盟ITU   <em>(制定通信规则)</em></li><li>国际电气电子工程师协会IEEE <em>(学术机构、IEEE802系列标准、5G)</em></li><li>Internet工程师任务组IETF  <em>(负责因特网相关标准的指定 RFCXXX)</em> </li></ul><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><blockquote><p>速率即数据率或称数据传输率或比特率</p></blockquote><ul><li>连接在计算机网络上的主机在数字信道上传送数据位数的速率</li><li>单位：b/s、kb/s、Mb/s、Gb/s、Tb/s</li><li>单位换算：<pre><code>   1kb/s=10^3b/s   1Mb/s=10^3kb/s=10^6b/s</code></pre></li></ul><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><ol><li>“带宽”原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹(Hz)</li><li>计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的”最高数据率”。单位是”比特每秒”,b/s,kb/s,Mb/s,Gb/s</li></ol><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><blockquote><p>表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b/s,kb/s,Mb/s等</p></blockquote><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><blockquote><p>指数据(报文/分组/比特流)从网络(或链路)的一端传送到另一端所需的时间，也叫延迟或迟延，单位是s。</p></blockquote><p><strong>时延可分为</strong></p><ol><li>发送时延(传输时延)：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间<ul><li>发送时延 = 数据长度 / 信道带宽(发送速率)</li></ul></li><li>传播时延：电磁波在信道上传播一定的距离所花费的时间(取决于电磁波传播速度和链路长度)<ul><li>传播时延 = 信道长度 / 电磁波在信道上的传播速率</li></ul></li><li>排队时延：等待输入/链路可用</li><li>处理时延：检错、找出口</li></ol><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><blockquote><p>时延带宽积 = 传播时延 x 带宽<br>又称为以比特为单位的链路长度</p></blockquote><h3 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h3><blockquote><p>从发送方发送数据开始，到发送方收到接收方的确认，总共经历的时延。<br><strong>RTT越大，在收到确认之前，可以发送的数据越多</strong><br>RTT包括：</p></blockquote><ol><li>往返传播时延 = 传播时延 * 2</li><li>末端处理时间</li></ol><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><strong>利用率分为：</strong></p><ol><li>信道利用率： 有数据通过时间 / (有+无)数据通过的时间</li><li>网络利用率： 信道利用率加权平均值</li></ol><h3 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h3><p><strong>分层的基本原则</strong></p><ol><li>各层之间相互独立，每层只实现一种相对独立的功能</li><li>每层之间界面自然清晰，易于理解，相互交流尽可能少</li><li>结构上可分割开，每层都采用最合适的技术来实现</li><li>保持下层对上层的独立性，上层单向使用下层提供的服务</li><li>整个分层结构应该能促进标准化工作</li></ol><p><strong>认识分层结构</strong></p><ol><li>实体：第n层中的活动元素称为n层实体。同一层的实体称为对等实体</li><li>协议：为进行网络中的对等实体数据交换而建立的规则，标准或约定称为网络协议</li><li>接口(访问服务点SAP)：上层使用下层服务的入口</li><li>服务：下层为相邻上层提供的功能调用</li></ol><p><strong>SDU服务数据单元</strong>：为完成用户所要求的功能而应传送的数据 <br><br><strong>PCI协议控制信息</strong>：控制协议操作的信息<br><br><strong>PDU协议数据单元</strong>：对等层次之间传送的数据单位</p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><table><thead><tr><th>应用层</th></tr></thead><tbody><tr><td><strong>表示层</strong></td></tr><tr><td><strong>会话层</strong></td></tr><tr><td><strong>传输层</strong></td></tr><tr><td><strong>网络层</strong></td></tr><tr><td><strong>数据链路层</strong></td></tr><tr><td><strong>物理层</strong></td></tr></tbody></table><ol><li>应用层：所有能和用户交互产生网络流量的程序<ul><li>主要协议：<ul><li>文件传输(FTP) </li><li>电子邮件(SMTP)</li><li>万维网(HTTP)</li></ul></li></ul></li><li>表示层：用于处理在两个通信系统中交换信息的表示方式(语法和语义)<ul><li>功能一：数据格式变换</li><li>功能二：数据加密解密</li><li>功能三：数据压缩和恢复</li><li>主要协议：JPEG、ASCII</li></ul></li><li>会话层：向表示层实体/用户进程提供<strong>建立连接</strong>并在连接上<strong>有序</strong>地<strong>传输</strong>数据<ul><li>功能一：建立、管理、终止会话</li><li>功能二：使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步(适用于传输大文件)</li></ul></li><li>传输层：负责主机中<strong>两个进程</strong>的通信，即<strong>端到端</strong>的通信。传输单位是报文段或用户数据报<ul><li>功能一：可靠传输、不可靠传输</li><li>功能二：差错控制</li><li>功能三：流量控制</li><li>功能四：复用分用<ul><li>复用：多个应用层进程可同时使用下面运输层的服务</li><li>分用：运输层把收到的信息分别交付给上面应用层中相应的进程</li></ul></li><li>主要协议：TCP、UDP</li></ul></li><li>网络层：主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是<strong>数据报</strong><ul><li>功能一：路由选择</li><li>功能二：流量控制</li><li>功能三：差错控制</li><li>功能四：拥塞控制：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于<strong>拥塞</strong>状态。因此要采用一定措施，缓解这种拥塞</li><li>主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</li></ul></li><li>数据链路层：主要任务是把网络层传下来的数据报<strong>组装成帧</strong>。数据链路层/链路层的传输单位是<strong>帧</strong><ul><li>功能一：成帧(定义帧的开始和结束)</li><li>功能二：差错控制 <strong>(帧错+位错)</strong></li><li>功能三：流量控制</li><li>功能四：访问(接入)控制 <strong>控制对信道的访问</strong></li><li>主要协议：SDLC、HDLC、PPP、STP</li></ul></li><li>物理层：主要任务是在<strong>物理媒体</strong>上实现比特流的<strong>透明传输</strong>。物理层传输单位是比特。<ul><li><strong>透明传输</strong>：指不管所传数据是什么样的比特组合，都应当能够在链路上传送 </li><li>功能一：定义接口特性</li><li>功能二：定义传输模式 <strong>(单工、半双工、双工)</strong></li><li>功能三：定义传输速率</li><li>功能四：比特同步</li><li>功能五：比特编码</li><li>主要协议：Rj45、802.3</li></ul></li></ol><h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h3><table><thead><tr><th>应用层</th></tr></thead><tbody><tr><td><strong>传输层</strong></td></tr><tr><td><strong>网际层</strong></td></tr><tr><td><strong>网络接口层</strong></td></tr></tbody></table><h3 id="OSI参考模型与TCP-IP参考模型相同点"><a href="#OSI参考模型与TCP-IP参考模型相同点" class="headerlink" title="OSI参考模型与TCP/IP参考模型相同点"></a>OSI参考模型与TCP/IP参考模型相同点</h3><ol><li>都分层</li><li>基于独立的协议栈概念</li><li>可以实现异构网络互联</li></ol><h3 id="OSI参考模型与TCP-IP参考模型不同点"><a href="#OSI参考模型与TCP-IP参考模型不同点" class="headerlink" title="OSI参考模型与TCP/IP参考模型不同点"></a>OSI参考模型与TCP/IP参考模型不同点</h3><ol><li>OSI定义三点：服务、协议、接口</li><li>OSI先出现，参考模型先于协议发明，不偏向特定协议</li><li>TCP/IP设计之初就考虑到异构网互联问题，将IP作为重要层次</li><li><table><thead><tr><th></th><th>ISO/OSI参考模型</th><th>TCP/IP参考模型</th></tr></thead><tbody><tr><td>网络层</td><td>无连接+面向连接</td><td>无连接</td></tr><tr><td>传输层</td><td>面向连接</td><td>无连接+面向连接</td></tr></tbody></table></li></ol><blockquote><p>面向连接分为三个阶段：第一个阶段是建立连接，在此阶段发出一个建立连接的请求。第二个阶段是连接成功建立之后，开始数据传输。第三个阶段，数据传输完成，必需释放连接。</p></blockquote><blockquote><p>无连接：直接进行数据传输</p></blockquote><h3 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h3><table><thead><tr><th>应用层</th></tr></thead><tbody><tr><td><strong>传输层</strong></td></tr><tr><td><strong>网络层</strong></td></tr><tr><td><strong>数据链路层</strong></td></tr><tr><td><strong>物理层</strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS笔记-字符串</title>
      <link href="2021/01/19/JS%E7%AC%94%E8%AE%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/01/19/JS%E7%AC%94%E8%AE%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a><strong>位置方法</strong></h3><ol><li>charAt()<ol><li>语法：string.charAt(index)</li><li>功能：返回string中index位置的字符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="number">1</span>]); <span class="comment">// &quot;e&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">0</span>)); <span class="comment">// &quot;h&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charCodeAt(<span class="number">4</span>));</span><br><span class="line"><span class="comment">// 111 charCodeAt()返回的是字符的编码 </span></span><br></pre></td></tr></table></figure></li></ol></li><li>indexOf()<ol><li>语法：string.indexOf(value);</li><li>功能：从一个字符串中搜索给定的子字符串，返回子字符串的位置</li><li>返回值：数值</li><li>说明：如果没有找到该子字符串，则返回-1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="string">&quot;marry.@sohu.com&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">&quot;rr&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">&quot;.&quot;</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li></ol></li><li>lastIndexOf()<ol><li>语法：string.lastIndexOf(value);</li><li>功能：从一个字符串中搜索给定的子字符串，返回子字符串的位置</li><li>返回值：数值</li><li>说明：如果没有找到该子字符串，则返回-1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="string">&quot;marry.@sohu.com&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">&quot;.&quot;</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h3 id="截取方法"><a href="#截取方法" class="headerlink" title="截取方法"></a><strong>截取方法</strong></h3></li></ol></li><li>slice()<ol><li>语法：string.slice(start,end)</li><li>功能：截取子字符串</li><li>参数说明：<ol><li>start：必需，指定子字符串的开始位置</li><li>end：可选，表示子字符串到哪里结束，end本身不在截取范围之内，省略时截取至字符串的末尾</li><li>当参数为负数时，会将传入的负值与字符串的长度相加<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello wolrd&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">7</span>,<span class="number">10</span>));</span><br><span class="line"><span class="comment">// olr</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"><span class="comment">// el</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(-<span class="number">3</span>));</span><br><span class="line"><span class="comment">// rld </span></span><br><span class="line"><span class="comment">// 相当于console.log(str.slice(11-3));</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li>substring()<ol><li>说明：语法及功能同slice()完全一样</li><li>区别：<ol><li>当参数为负数时，自动将参数转换为0</li><li>substring()会将较小的数作为开始位置，将较大的数作为结束位置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.substring(-<span class="number">2</span>,-<span class="number">2</span>)); <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">2</span>,-<span class="number">2</span>)); <span class="comment">// 相当于(0,2)</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li>substr()<ol><li>语法：string.substr(start,len)</li><li>功能：截取子字符串</li><li>参数说明：<ol><li>start：必需，指定子字符串的开始位置</li><li>len：可选，表示截取的字符总数，省略时截取至字符串的末尾</li><li>当start为负数时，会将传入的负值与字符串的长度相加</li><li>当len为负数时，返回空字符串<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">6</span>,<span class="number">3</span>));</span><br><span class="line"><span class="comment">// wor</span></span><br><span class="line"><span class="comment">// 等价于 str.substring(6,9)</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(-<span class="number">5</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">// worl</span></span><br><span class="line"><span class="comment">// 相当于 等价于 str.substr(11-5,4)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>,-<span class="number">4</span>); <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a><strong>其他方法</strong></h3></li></ol></li></ol></li><li>split()<ol><li>语法：string.split(separator)</li><li>功能：把一个字符串分割成字符串数组</li><li>返回值：Array</li><li>说明：separator：必需，分隔符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello-world-c&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [&quot;hello&quot;,&quot;world&quot;,&quot;c&quot;];</span></span><br></pre></td></tr></table></figure></li></ol></li><li>replace()<ol><li>语法：string.replace(regexp/substr,replacement)</li><li>功能：在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串</li><li>返回值：String</li><li>参数：<ol><li>regexp：必需。规定子字符串或要替换的模式的RegExp对象</li><li>replacement：必需。一个字符串值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;010-62921312,400-100-9087,010-3421412&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.replace(<span class="string">&quot;,&quot;</span>,<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newStr); <span class="comment">// &quot;010-62921312 400-100-9087 010-3421412&quot;</span></span><br></pre></td></tr></table></figure><h3 id="转换大小写方法"><a href="#转换大小写方法" class="headerlink" title="转换大小写方法"></a><strong>转换大小写方法</strong></h3></li></ol></li></ol></li><li>toUpperCase()<ol><li>语法：string.toUpperCase()</li><li>功能：把字符串转换为大写</li></ol></li><li>toLowerCase()<ol><li>语法：string.toLowerCase()</li><li>功能：把字符串转换为小写</li></ol></li></ol><h3 id="实例：将字符串转为驼峰命名"><a href="#实例：将字符串转为驼峰命名" class="headerlink" title="实例：将字符串转为驼峰命名"></a><strong>实例：将字符串转为驼峰命名</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">funciton <span class="function"><span class="title">camelBack</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"><span class="comment">//首先将字符串转换为数组</span></span><br><span class="line"><span class="keyword">let</span> arr = str.split(<span class="string">&quot;-&quot;</span>),newStr = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">let</span> word = arr[i];</span><br><span class="line">newStr += word.charAt(<span class="number">0</span>).toUpperCase() + word.substr(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newStr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;border-left-color&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS笔记-数组</title>
      <link href="2021/01/19/JS%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/"/>
      <url>2021/01/19/JS%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a><strong>创建数组</strong></h3><ol><li>使用Array构造函数<ul><li>语法：new Array()</li><li>小括号说明：<ul><li>预先知道数组要保存的长度</li><li>向Array构造函数传递数组应包含的项<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>使用数组字面量表示法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="attr">name</span>:<span class="string">&quot;mike&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;];</span><br></pre></td></tr></table></figure><h3 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a><strong>数组长度</strong></h3></li><li>语法：array.length</li><li>功能：获取数组array的长度</li><li>返回值：number</li><li>说明：<ul><li>通过设置length可以从数组的末尾移除项或向数组中添加新项。</li><li>把一个值放在超出当前数组大小的位置上时，会重新计算数组长度值，长度值等于最后一项索引加1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 4</span></span><br><span class="line">arr[<span class="number">99</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><h3 id="数组的栈方法"><a href="#数组的栈方法" class="headerlink" title="数组的栈方法"></a><strong>数组的栈方法</strong></h3></li></ul></li><li>push()<ul><li>语法：array.push(newele1,newele2,…);</li><li>功能：把它的参数顺序添加到array的尾部</li><li>返回值：把指定的值添加到数组后的长度<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newLen = arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1,2,3,4];</span></span><br><span class="line"><span class="built_in">console</span>.log(newLen); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li></ul></li><li>unshift()<ul><li>语法：array.unshift(newele1,newele2,…);</li><li>功能：把它的参数顺序添加到array的开头</li><li>返回值：把指定的值添加到数组的新长度<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newLen = arr.unshift(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr,newLen); <span class="comment">// [1,2,3,4],4</span></span><br></pre></td></tr></table></figure></li></ul></li><li>pop()<ul><li>语法：array.pop()</li><li>功能：删除array的最后一个元素</li><li>返回值：被删除的元素<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> delEmt = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(arr,delEmt); <span class="comment">// [1,2],3</span></span><br></pre></td></tr></table></figure></li></ul></li><li>shift()<ul><li>语法：array.shift()</li><li>功能：删除array的第一个元素</li><li>被删除的元素<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> delEmt = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(arr,delEmt); <span class="comment">// [2,3],1</span></span><br></pre></td></tr></table></figure><h3 id="数组的转换方法"><a href="#数组的转换方法" class="headerlink" title="数组的转换方法"></a><strong>数组的转换方法</strong></h3></li></ul></li><li>join()<ul><li>语法：array.join(separator)</li><li>功能：用于把数组中的所有元素放入一个字符串</li><li>返回值：字符串<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> str = arr.join();</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 2,3,4</span></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colorStr = colors.join(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colorStr); <span class="comment">// red-green-blue</span></span><br></pre></td></tr></table></figure></li></ul></li><li>reverse()<ul><li>语法：array.reverse()</li><li>功能：用于颠倒数组中元素的顺序</li><li>返回值：数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [4,3,2];</span></span><br></pre></td></tr></table></figure></li></ul></li><li>sort()<ul><li>语法：array.sort(sortby)</li><li>功能：用于对数组的元素进行排序</li><li>返回值：数组</li><li>说明<ul><li>即使数组中的每一项都是数值，sort()方法比较的也是字符串</li><li>sort()方法可以接收一个比较函数作为参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;color&quot;</span>,<span class="string">&quot;border&quot;</span>,<span class="string">&quot;ab&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort()); <span class="comment">// [&quot;ab&quot;,&quot;border&quot;,&quot;color&quot;]</span></span><br><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">81</span>];</span><br><span class="line"><span class="built_in">console</span>.log(nums.sort()); <span class="comment">// [1,4,81,9]</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.sort(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-b</span><br><span class="line">        &#125;)</span><br><span class="line">    ); <span class="comment">// [1,4,9,81];</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>concat()<ul><li>语法：array.concat(arr1,arr2,…);</li><li>功能：用于连接两个或多个数组</li><li>返回值：数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr3 = arr1.concat(arr2,[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>); <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure></li></ul></li><li>slice()<ul><li>语法：array.slice(start,end)<blockquote><p>start和end指的时数组中索引值，<br>截取从start和end的元素，即从start和end-1的元素</p></blockquote></li><li>功能：从已有的数组中返回选定的元素</li><li>返回值：数组</li><li>参数：<ul><li>start(必需)规定从何处开始选取，如果时负数，则规定从数组尾部开始算起的位置</li><li>end(可选)规定从何处结束选取，该参数是数组片段结束处的数组下标</li></ul></li><li>说明：<ul><li>如果未指定end，切分的数组包含从start到数组结束的所有元素</li><li>如slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;yellow&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">2</span>)); <span class="comment">// [&quot;blue&quot;,&quot;yellow&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>,<span class="number">4</span>)); </span><br><span class="line"><span class="comment">// [&quot;green,&quot;,&quot;blue&quot;,&quot;yellow&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(-<span class="number">2</span>,<span class="number">4</span>)); </span><br><span class="line"><span class="comment">// [&quot;blue&quot;,&quot;yellow&quot;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><strong>splice()</strong><ol><li>删除：<ol><li>语法：array.splice(index,count)</li><li>功能：删除从index处开始的零个或多个元素</li><li>返回值：含有被删除的元素的数组</li><li>说明：count是删除的项目数量，如果设置为0，则不会删除项目。如果不设置，则删除从index开始的所有值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;f&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> delArr = arr.splice(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(delArr); <span class="comment">// [&quot;c&quot;,&quot;d&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">2</span>,<span class="number">0</span>)); <span class="comment">// []</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li>插入：<ol><li>语法：array.splice(index,0,item1,…itemx)</li><li>功能：在指定位置插入值</li><li>参数：<pre><code>   1. index：起始位置   2.    0：要删除的项数    3. item1,...itemx：要插入的项</code></pre></li><li>返回值：数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;f&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> insertArr = arr.splice(<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,1,2,&quot;d&quot;,&quot;f&quot;]</span></span><br></pre></td></tr></table></figure></li></ol></li><li>替换<ul><li>语法：array.splice(index,count1,item1,..,itemx)</li><li>功能：在指定位置插入值，且同时删除任意数量的项</li><li>参数：<ul><li>index：起始位置</li><li>count：要删除的项数</li><li>item1,…,itemx：要插入的项</li></ul></li><li>返回值：从原始数组中删除的项(如果没有删除任何项，则返回空数组)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;f&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> reArr = arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); </span><br><span class="line"><span class="comment">// [&quot;a&quot;,&quot;x&quot;,&quot;y&quot;,&quot;d&quot;,&quot;f&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(reArr);</span><br><span class="line"><span class="comment">// [&quot;b&quot;,&quot;c&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a><strong>位置方法</strong></h3></li></ul></li><li>indexOf()<ul><li>语法：array.indexOf(searchvalue,startIndex)</li><li>功能：从数组的开头(位置0)开始向后查找</li><li>参数：<ul><li>searchvalue：必需，要查找的项</li><li>startIndex：可选，起点位置的索引</li><li>返回值：number，查找的项在数组中的位置，没有找到的情况下返回-1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> pos = nums.indexOf(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pos); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.indexOf(<span class="number">99</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.indexOf(<span class="number">7</span>,<span class="number">3</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>lastIndexOf()<ul><li>语法：array.lastIndexOf(searchvalue,startIndex)</li><li>功能：从数组的末尾开始向后查找</li><li>参数：<ul><li>searchvalue：必需，要查找的项</li><li>startIndex：可选，起点位置的索引</li><li>返回值：number，查找的项在数组中的位置，没有找到的情况下返回-1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> pos = nums.lastIndexOf(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pos); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.indexOf(<span class="number">99</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(nums.indexOf(<span class="number">1</span>,<span class="number">3</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS笔记-基本语法</title>
      <link href="2021/01/17/JS%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>2021/01/17/JS%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><ul><li><p>功能：检测变量类型</p></li><li><p>返回值：string number boolean object undefined function</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h3 id="null-与-undefined"><a href="#null-与-undefined" class="headerlink" title="null 与 undefined"></a>null 与 undefined</h3></li><li><p>undefined值是派生自null值的，所以undefined == null 的返回结果是true。</p><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><h3 id="Number：表示整数和浮点数"><a href="#Number：表示整数和浮点数" class="headerlink" title="Number：表示整数和浮点数"></a>Number：表示整数和浮点数</h3><h3 id="NaN：非数值-是一个特殊的数值"><a href="#NaN：非数值-是一个特殊的数值" class="headerlink" title="NaN：非数值 是一个特殊的数值"></a>NaN：非数值 是一个特殊的数值</h3></li><li><p>任何涉及NaN的操作都会返回NaN</p></li><li><p>NaN与任何值都不相等，包括NaN本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> * <span class="number">1</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3></li><li><p>功能：检测n是否是“非数值”</p></li><li><p>参数：参数可以是任何类型</p><blockquote><p>isNaN()对接收的数值，先尝试转换为数值，再检测是否为非数值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;123&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3></li></ul><ol><li>Number()</li><li>parseInt()</li><li>parseFloat()</li></ol><ul><li>Number()可以用于任何数据类型</li><li>parseInt()和parseFloat()则专门用于把字符串转换为数值</li></ul><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><ul><li>parseInt()：会忽略字符串前面的空格，直到找到第一个非空格字符。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;  123&quot;</span>)); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><ul><li>转换空字符串或空格字符串返回NaN</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;  &quot;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><ul><li>此函数提供第二个参数：转换时使用的基数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;15&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(a,<span class="number">8</span>)); <span class="comment">// 13(5+8)</span></span><br></pre></td></tr></table></figure><h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><ul><li>parseFloat：从第一个字符开始解析每个字符，直到遇见第一个无效的浮点数字符为止。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;13.23.21&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(a)); <span class="comment">// 13.23</span></span><br></pre></td></tr></table></figure><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="toString-与String"><a href="#toString-与String" class="headerlink" title="toString()与String()"></a>toString()与String()</h3><ul><li>语法：str.toString()</li><li>功能：将str转换成字符串</li><li>返回值：str的一个副本</li><li>参数：str是要转换的内容，可以是数值、布尔值、对象和字符串。</li><li>说明：在不知道要转换的值是不是null或undefined的情况下，还可以使用String()函数，它能够将任何类型的值转换为字符串。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>,b = <span class="number">13</span>;</span><br><span class="line">b = b.toString();</span><br><span class="line">a = <span class="built_in">String</span>(a);</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">// &quot;null&quot; &quot;13&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>除了0之外的所有数字，转换为布尔型都为true</li><li>除了””之外的所有字符，转换为布尔型都为true</li><li>null和undefined转换为布尔型都为false</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="算数操作符"><a href="#算数操作符" class="headerlink" title="算数操作符"></a>算数操作符</h2><h3 id="递增"><a href="#递增" class="headerlink" title="递增"></a>递增</h3><ul><li>++a与a++都是对a进行递增的操作</li><li>区别：<ul><li>++a先返回递增之后的a的值</li><li>a++先返回a的原值，再返回递增之后的值</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a++); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(++a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h2><h3 id="：相等，只比较值是否相等"><a href="#：相等，只比较值是否相等" class="headerlink" title="==：相等，只比较值是否相等"></a>==：相等，只比较值是否相等</h3><h3 id="：相等，比较值的同时比较数据类型是否相等"><a href="#：相等，比较值的同时比较数据类型是否相等" class="headerlink" title="===：相等，比较值的同时比较数据类型是否相等"></a>===：相等，比较值的同时比较数据类型是否相等</h3><h3 id="：不相等，比较值是否不相等"><a href="#：不相等，比较值是否不相等" class="headerlink" title="!=：不相等，比较值是否不相等"></a>!=：不相等，比较值是否不相等</h3><h3 id="！-：不相等，比较值的同时比较数据类型是否不相等"><a href="#！-：不相等，比较值的同时比较数据类型是否不相等" class="headerlink" title="！==：不相等，比较值的同时比较数据类型是否不相等"></a>！==：不相等，比较值的同时比较数据类型是否不相等</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,b = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a==b); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a===b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><h3 id="逻辑与-amp-amp-只要有一个条件不成立，返回false"><a href="#逻辑与-amp-amp-只要有一个条件不成立，返回false" class="headerlink" title="逻辑与&amp;&amp;(只要有一个条件不成立，返回false)"></a>逻辑与&amp;&amp;(只要有一个条件不成立，返回false)</h3><ul><li>说明：在有一个操作数不是布尔值的情况，逻辑与操作就不一定返回值，此时它遵循下列规则：<ul><li>如果第一个操作数隐式类型转换后为true，则返回后一个操作数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &amp;&amp; <span class="number">0</span> &amp;&amp; <span class="string">&quot;abc&quot;</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li>如果第一个操作数隐式类型转换后为false，则返回第一个操作数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> &amp;&amp; <span class="string">&quot;1&quot;</span> &amp;&amp; <span class="literal">true</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li>如果后面有一个操作数是null，且null之前的操作数隐式类型转换后为true,则返回null<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span> &amp;&amp; <span class="number">1</span> &amp;&amp; <span class="literal">null</span>); <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span> &amp;&amp; <span class="number">0</span> &amp;&amp; <span class="literal">null</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li>如果后面有一个操作数是NaN，且NaN之前的操作数隐式类型转换后为true,则返回NaN<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span> &amp;&amp; <span class="number">1</span> &amp;&amp; <span class="literal">NaN</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span> &amp;&amp; <span class="number">0</span> &amp;&amp; <span class="literal">NaN</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li>如果后面有一个操作数是undefined，且undefined之前的操作数隐式类型转换后为true,则返回undefined<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span> &amp;&amp; <span class="number">1</span> &amp;&amp; <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span> &amp;&amp; <span class="number">0</span> &amp;&amp; <span class="number">0</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="逻辑或-只要有一个条件成立，返回true"><a href="#逻辑或-只要有一个条件成立，返回true" class="headerlink" title="逻辑或||(只要有一个条件成立，返回true)"></a>逻辑或||(只要有一个条件成立，返回true)</h3></li></ul></li><li>说明：在有一个操作数不是布尔值的情况，逻辑或操作就不一定返回值，此时它遵循下列规则：<ul><li>如果第一个操作数隐式类型转换后为true，则返回第一个操作数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span> || <span class="number">0</span> || <span class="literal">true</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li>如果第一个操作数隐式类型转换后为false，则一直往后，若没有隐式转换为true的操作数,则返回最后一个操作数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;&quot;</span> || <span class="number">0</span> || <span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> || <span class="literal">true</span> || <span class="string">&quot;&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li>如果两个操作数是null，则返回null<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> || <span class="literal">null</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li><li>如果两个操作数是NaN，则返回NaN<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> || <span class="literal">NaN</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li><li>如果两个操作数是undefined，则返回undefined<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> || <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="逻辑非！"><a href="#逻辑非！" class="headerlink" title="逻辑非！"></a>逻辑非！</h3></li></ul></li><li>无论操作数是什么数据类型，逻辑非都会返回一个布尔值</li><li>！！同时使用两个逻辑非操作符时<ul><li>第一个逻辑非操作会基于无论什么操作数返回一个布尔值</li><li>第二个逻辑非则对该布尔值求反<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(!!a); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS笔记-DOM事件流</title>
      <link href="2020/12/06/JS%E7%AC%94%E8%AE%B0-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
      <url>2020/12/06/JS%E7%AC%94%E8%AE%B0-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><p>事件流描述的是从页面中接收事件的顺序。<br>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。</p><h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><p>DOM事件流分为三个阶段：<br>1.捕获阶段<br>2.当前目标阶段<br>3.冒泡阶段</p><p><img src="https://img-blog.csdnimg.cn/20201206104218771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhbnl1YW5h,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>注意</strong></p><ol><li>JS 代码中只能执行捕获或者冒泡其中的一个阶段。</li><li>onclick 和 attachEvent 只能得到冒泡阶段。</li><li>addEventListener(type, listener[, useCapture])第三个参数<strong>如果是 true</strong>，表示在<strong>事件捕<br>获阶段</strong>调用事件处理程序；<strong>如果是 false</strong>（不写默认就是false），表示在<strong>事件冒泡阶段</strong>调用事件处理<br>程序。</li><li>实际开发中很少使用事件捕获，而是更关注事件冒泡。</li></ol><p>举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> father = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.father&#x27;</span>);</span><br><span class="line"></span><br><span class="line">son.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;son&#x27;</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">father.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;father&#x27;</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>由于addEventListener函数的第三个参数是false，因此在事件冒泡阶段才调用事件处理程序，因此当点击son盒子时，<br>出现了以下结果</p><p><img src="https://img-blog.csdnimg.cn/20201206105056317.png#pic_center" alt="在这里插入图片描述"></p><p><strong>使用stopPropagation() 来阻止时间冒泡</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">son.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;son&#x27;</span>);</span><br><span class="line">e.stopPropagation();</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>将son的事件监听函数改为上述，即可阻止事件冒泡，原理就是事件对象使用了stopPropagation() 函数。</p><p><strong>利用冒泡，通过事件委托实现给父元素增加监听器，影响子元素</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querSelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">ul.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">e.target.style.backgroundColor = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>上述代码实现点击每个li，每个li背景颜色改变。其原理就是通过给li的父元素ul设置监听器，通过事件委托而实现的。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-清除浮动</title>
      <link href="2020/11/14/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
      <url>2020/11/14/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h3><p><em>由于父盒子在很多情况下，不方便给高度，但子盒子浮动后又不占又位置，因此需要清除浮动防止父元素高度塌陷</em><br>&nbsp;</p><h4 id="清除浮动的本质"><a href="#清除浮动的本质" class="headerlink" title="清除浮动的本质"></a>清除浮动的本质</h4><ul><li>清除浮动的本质是清除浮动元素造成的影响</li><li>如果父盒子本身有高度，则不需要清除浮动</li><li>清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了<br>&nbsp;<h4 id="清除浮动的策略"><a href="#清除浮动的策略" class="headerlink" title="清除浮动的策略"></a>清除浮动的策略</h4></li><li>闭合浮动，只会让浮动在父盒子内部影响，不影响父盒子外部的其他盒子<br>&nbsp;<h3 id="清除浮动的四种方法"><a href="#清除浮动的四种方法" class="headerlink" title="清除浮动的四种方法"></a>清除浮动的四种方法</h3><h4 id="1-额外标签法或隔墙法-（新增加的盒子必须是块级元素）"><a href="#1-额外标签法或隔墙法-（新增加的盒子必须是块级元素）" class="headerlink" title="1.额外标签法或隔墙法,（新增加的盒子必须是块级元素）"></a>1.额外标签法或隔墙法,<strong>（新增加的盒子必须是块级元素）</strong></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">          <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="selector-class">.fl</span> &#123;</span><br><span class="line">          <span class="attribute">float</span>: left;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">          <span class="attribute">background-color</span>: red;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      <span class="selector-class">.fr</span> &#123;</span><br><span class="line">          <span class="attribute">float</span>: right;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">          <span class="attribute">background-color</span>: blue;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="selector-class">.clear</span>&#123;</span><br><span class="line">      <span class="attribute">clear</span>:both;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fl&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fr&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 新增加的盒子必须要求是块级元素 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-父级添加overflow属性"><a href="#2-父级添加overflow属性" class="headerlink" title="2.父级添加overflow属性"></a>2.父级添加overflow属性</h4><p>优点：代码简洁<br>   缺点：无法显示溢出部分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">           <span class="comment">/* 清除浮动 */</span></span><br><span class="line">           <span class="attribute">overflow</span>: hidden;</span><br><span class="line">           <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fl&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fr&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>此方法触发了BFC</strong></p><p><strong>什么是BFC</strong></p><p>BFC(Block Formatting Context) 块级格式化环境<br>BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC，开启BFC该元素会变成一个独立的布局区域</p><p><strong>元素开启BFC的特点：</strong><br>1.开启BFC的元素不会被浮动元素所覆盖<br>2.开启BFC的元素子元素和父元素外边距不会重叠<br>3.开启BFC的元素可以包含浮动的子元素</p><p><strong>可以通过一些特殊方式来开启元素的BFC:</strong><br>1.设置元素的浮动(不推荐)<br>2.将元素设置为行内块元素(不推荐)<br>3.将元素的overflow设置为一个非visible的值<br><em>常用的方式为元素设置 overflow:hidden; 以开启其BFC,使其开启包含浮动元素,防止高度塌陷</em></p><h4 id="3-父级添加after伪元素"><a href="#3-父级添加after伪元素" class="headerlink" title="3.父级添加after伪元素"></a>3.父级添加after伪元素</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">          <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">          <span class="attribute">display</span>: block;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">          <span class="attribute">clear</span>: both;</span><br><span class="line">          <span class="attribute">visibility</span>: hidden;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3 clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fl&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fr&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4、父级添加双伪元素（clearfix这个样式可以同时解决高度塌陷和外边距重叠的问题）"><a href="#4、父级添加双伪元素（clearfix这个样式可以同时解决高度塌陷和外边距重叠的问题）" class="headerlink" title="4、父级添加双伪元素（clearfix这个样式可以同时解决高度塌陷和外边距重叠的问题）"></a>4、父级添加双伪元素（clearfix这个样式可以同时解决高度塌陷和外边距重叠的问题）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line">   <span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">           <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">           <span class="attribute">display</span>: table;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   <span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">           clear: both;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box4 clearfix&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fl&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fr&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML与CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML与CSS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
